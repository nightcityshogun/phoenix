<#
.SYNOPSIS
Recreates and rotates all gMSA accounts and KDS root keys across isolated domains.

.DESCRIPTION
Set-GMSA validates ONLINE writable DCs, orders Forest Root → Child → Tree Root, and creates a new KDS root key
(effective now or offset). All LDAP/DC operations are server-pinned to per-domain anchor DCs (PDC only),
and all KDS work is bound to the forest-root PDC. It restarts kdsSvc on DCs, disables and removes existing gMSAs,
then recreates them with restored attributes. Optionally rebinds computers’ msDS-HostServiceAccount entries.
Deletes old KDS keys after replication. Runs in WhatIf unless -Execute is supplied.

Safety:
- If the forest root PDC is not ONLINE / not provided, the function logs an error and exits (no KDS, no gMSA work).
- If a child/tree domain has no ONLINE PDC, that domain is skipped and clearly logged.

.PARAMETER IsolatedDCList
DC inventory objects with at least: FQDN, Domain, DefaultNamingContext, Type, IsPdcRoleOwner, Online.
Domain should be the DNS domain name (e.g. contoso.com).

.PARAMETER CleanupTag
String tag placed in adminDescription of old gMSAs (default: 'cleanup-gmsa') and appended to their description.

.PARAMETER RebindHosts
When used, rebinds computers to recreated gMSAs (msDS-HostServiceAccount).

.PARAMETER Execute
Apply changes; omit to simulate (WhatIf=True).

.PARAMETER EffectiveImmediately
Create KDS key effective immediately (default). Uses current time and backdates EffectiveTime by 10 hours.

.PARAMETER EffectiveTimeHoursOffset
Offset in hours for new KDS key usability (default 0). Ignored when -EffectiveImmediately is set.

.EXAMPLE
# Simulate full gMSA rotation (no changes)
Set-GMSA -IsolatedDCList $dcs

.EXAMPLE
# Apply with host rebinding
Set-GMSA -IsolatedDCList $dcs -RebindHosts -Execute

.OUTPUTS
None. Progress logged via Write-IdentIRLog.

.NOTES
Author: NightCityShogun
Version: 1.3
Requires: Add-KdsRootKey, ADSI, CIM/WMI, Domain/Enterprise Admin privileges.
SupportsShouldProcess: True
© 2025 NightCityShogun. All rights reserved.
#>
function Set-GMSA {
    [CmdletBinding(SupportsShouldProcess = $true)]
    param(
        [Parameter(Mandatory, ValueFromPipeline)]
        [AllowEmptyCollection()]
        [PSObject[]]$IsolatedDCList,

        [string]$CleanupTag = 'cleanup-gmsa',
        [switch]$RebindHosts,
        [switch]$Execute,

        # KDS timing (defaults keep current behavior)
        [switch]$EffectiveImmediately = $true,
        [int]$EffectiveTimeHoursOffset = 0
    )

    begin {
        $ErrorActionPreference = 'Stop'
        Set-StrictMode -Version Latest

        $doExec = [bool]$Execute
        $whatIf = -not $doExec

        # --- helpers ---
        $GetDe = { param([string]$Path) [ADSI]$Path }

        $WI = {
            param([string]$Message)
            if ($whatIf) {
                Write-IdentIRLog -Message "[WHATIF] $Message" -TypeName 'Info' -ForegroundColor Green
            }
        }

        function Get-KdsRootKeys {
            param(
                [string]$BindServer,
                [scriptblock]$GetDe
            )
            $keys = New-Object System.Collections.Generic.List[psobject]
            try {
                $rootDse = & $GetDe ("LDAP://$BindServer/RootDSE")
                $cfgNC   = $rootDse.Properties['configurationNamingContext'][0]
                $kdsPath = "LDAP://$BindServer/CN=Master Root Keys,CN=Group Key Distribution Service,CN=Services,$cfgNC"
                $searchRoot = & $GetDe $kdsPath
                $ds = New-Object System.DirectoryServices.DirectorySearcher($searchRoot)
                $ds.Filter = '(objectClass=msKds-ProvRootKey)'
                $ds.PageSize = 1000
                $ds.SearchScope = [System.DirectoryServices.SearchScope]::OneLevel
                $ds.PropertiesToLoad.AddRange(@('distinguishedName','cn','whenCreated')) | Out-Null

                foreach ($r in $ds.FindAll()) {
                    $dn = $r.Properties['distinguishedname'][0]
                    $cn = $r.Properties['cn'][0]
                    $wc = if ($r.Properties['whencreated']) { [datetime]$r.Properties['whencreated'][0] } else { $null }
                    $keys.Add([pscustomobject]@{
                        DistinguishedName = $dn
                        CN                = $cn
                        WhenCreated       = $wc
                    })
                }
            } catch {
                Write-IdentIRLog -Message "KDS query failed on $BindServer: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
            }
            return ,$keys
        }

        function Remove-KdsRootKeys {
            param(
                [string]$BindServer,
                [scriptblock]$GetDe,
                [psobject[]]$OldKeys,
                [bool]$WhatIfLocal
            )
            $count = 0
            if (-not $OldKeys) { return 0 }
            try {
                $rootDse = & $GetDe ("LDAP://$BindServer/RootDSE")
                $cfgNC   = $rootDse.Properties['configurationNamingContext'][0]
                $kdsPath = "LDAP://$BindServer/CN=Master Root Keys,CN=Group Key Distribution Service,CN=Services,$cfgNC"
                $container = & $GetDe $kdsPath
                foreach ($key in $OldKeys) {
                    try {
                        if ($WhatIfLocal) {
                            Write-IdentIRLog -Message "[WHATIF] Delete KDS root key CN=$($key.CN) on $BindServer" -TypeName 'Info' -ForegroundColor Green
                            $count++
                        } else {
                            $container.Delete("msKds-ProvRootKey","CN=$($key.CN)")
                            $count++
                        }
                    } catch {
                        Write-IdentIRLog -Message "Delete KDS key $($key.CN) failed on $BindServer: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                    }
                }
            } catch {
                Write-IdentIRLog -Message "KDS container lookup failed on $BindServer: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
            }
            return $count
        }

        function Restart-KdsService {
            param([string]$ComputerName,[bool]$WhatIfLocal)

            if ($WhatIfLocal) {
                Write-IdentIRLog -Message "[WHATIF] Restart kdsSvc on $ComputerName" -TypeName 'Info' -ForegroundColor Green
                return
            }
            try {
                $c = @{
                    ClassName    = 'Win32_Service'
                    Filter       = "Name='kdsSvc'"
                    ComputerName = $ComputerName
                }
                $svc = Get-CimInstance @c
                if (-not $svc) {
                    Write-IdentIRLog -Message "kdsSvc not found on $ComputerName" -TypeName 'Warning' -ForegroundColor Yellow
                    return
                }
                $null = $svc | Invoke-CimMethod -MethodName StopService | Out-Null
                $deadline = (Get-Date).AddSeconds(60)
                while ($svc.State -ne 'Stopped' -and (Get-Date) -lt $deadline) {
                    $svc = Get-CimInstance @c
                    Start-Sleep -Milliseconds 200
                }
                if ($svc.State -ne 'Stopped') {
                    Write-IdentIRLog -Message "kdsSvc stop timeout on $ComputerName" -TypeName 'Warning' -ForegroundColor Yellow
                }
                $null = $svc | Invoke-CimMethod -MethodName StartService | Out-Null
                $deadline = (Get-Date).AddSeconds(60)
                while ($svc.State -ne 'Running' -and (Get-Date) -lt $deadline) {
                    $svc = Get-CimInstance @c
                    Start-Sleep -Milliseconds 200
                }
                if ($svc.State -ne 'Running') {
                    Write-IdentIRLog -Message "kdsSvc start timeout on $ComputerName" -TypeName 'Warning' -ForegroundColor Yellow
                } else {
                    Write-IdentIRLog -Message "kdsSvc restarted on $ComputerName" -TypeName 'Info' -ForegroundColor Green
                }
            } catch {
                Write-IdentIRLog -Message "kdsSvc restart failed on $ComputerName: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
            }
        }

        function Force-ConfigReplication {
            param(
                [string]$SourceDC,
                [string]$CfgNC
            )
            try {
                repadmin /syncall $SourceDC $CfgNC /d /e /P
                Write-IdentIRLog -Message "Config NC replication from $SourceDC started" -TypeName 'Info' -ForegroundColor Green
            } catch {
                Write-IdentIRLog -Message "Config NC replication from $SourceDC failed: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
            }
        }

        # --- validate DC list ---
        $in = @($IsolatedDCList)
        if (-not $in -or $in.Count -eq 0) {
            Write-IdentIRLog -Message "IsolatedDCList is empty. Nothing to do." -TypeName 'Error' -ForegroundColor Red
            return
        }

        $validated = New-Object System.Collections.Generic.List[psobject]
        foreach ($dc in $in) {
            $required = @('FQDN','Domain','DefaultNamingContext','Type','IsPdcRoleOwner','Online')
            $missing = $required | Where-Object {
                -not $dc.PSObject.Properties[$_] -or
                $null -eq $dc.$_ -or
                ($dc.$_.ToString() -eq '')
            }
            if ($missing) {
                Write-IdentIRLog -Message "Skip $($dc.FQDN): missing $($missing -join ', ')" -TypeName 'Warning' -ForegroundColor Yellow
                continue
            }
            $validated.Add($dc)
        }

        if (@($validated).Count -eq 0) {
            Write-IdentIRLog -Message "No valid DC entries after validation. Exit." -TypeName 'Error' -ForegroundColor Red
            return
        }

        # Single forest check
        $forestRoots = New-Object System.Collections.Generic.HashSet[string]
        foreach ($dc in $validated | Where-Object { $_.Online }) {
            try {
                $rootDse = & $GetDe ("LDAP://$($dc.FQDN)/RootDSE")
                [void]$forestRoots.Add($rootDse.Properties['rootDomainNamingContext'][0])
            } catch {
                Write-IdentIRLog -Message "RootDSE query failed on $($dc.FQDN): $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
            }
        }
        if ($forestRoots.Count -gt 1) {
            Write-IdentIRLog -Message "Multiple forests detected. Only one forest is supported. Exit." -TypeName 'Error' -ForegroundColor Red
            return
        }
        if ($forestRoots.Count -eq 0) {
            Write-IdentIRLog -Message "No forest root detected from IsolatedDCList. Exit." -TypeName 'Error' -ForegroundColor Red
            return
        }

        $forestRootNc = $forestRoots | Select-Object -First 1

        # Ordering: Forest Root → Child → Tree Root; PDC first
        $priority = @{ 'Forest Root' = 1; 'Child Domain' = 2; 'Tree Root' = 3 }
        $groups   = $validated | Group-Object -Property Domain
        $meta     = @{}
        foreach ($g in $groups) {
            $rep = $g.Group | Select-Object -First 1
            $meta[$g.Name] = @{
                Type      = $rep.Type
                DefaultNC = $rep.DefaultNamingContext
                Domain    = $g.Name
            }
        }

        # Build per-domain anchor DC map (PDC ONLY – no fallback)
        $script:DomainAnchors = @{}
        foreach ($g in $groups) {
            $pdc = $g.Group | Where-Object { $_.IsPdcRoleOwner -and $_.Online } | Select-Object -First 1
            if ($pdc) {
                $script:DomainAnchors[$g.Name.ToLower()] = $pdc.FQDN
                Write-IdentIRLog -Message "PDC for $($g.Name): $($pdc.FQDN)" -TypeName 'Info' -ForegroundColor Green
            } else {
                Write-IdentIRLog -Message "No ONLINE PDC for $($g.Name). This domain will be skipped." -TypeName 'Warning' -ForegroundColor Yellow
            }
        }

        # Order domains: forest root → children → other tree roots
        $orderedDomains = ($groups.Name) | Sort-Object {
            $t = $meta[$_].Type
            if ($priority.ContainsKey($t)) { $priority[$t] } else { 4 }
        }, $_

        Write-IdentIRLog -Message ("Domains discovered: {0} (WhatIf={1})" -f @($orderedDomains).Count, $whatIf) -TypeName 'Info' -ForegroundColor Cyan

        # shared state
        $script:validated      = $validated
        $script:orderedDomains = $orderedDomains
        $script:meta           = $meta
        $script:GetDe          = $GetDe
        $script:whatIf         = $whatIf

        $script:DesiredUsableTime = if ([bool]$EffectiveImmediately -or ($EffectiveTimeHoursOffset -eq 0)) {
            Get-Date
        } else {
            (Get-Date).AddHours($EffectiveTimeHoursOffset)
        }

        $script:KdsEffectiveTime = $script:DesiredUsableTime.AddHours(-10)
        $script:newKdsCn         = $null
        $script:existingKeyCount = 0
        $script:oldKeys          = @()

        # Forest root DNS name
        $forestRootDomain = ($forestRootNc -replace '^DC=', '' -replace ',DC=', '.').ToLower()
        if (-not $forestRootDomain) {
            Write-IdentIRLog -Message "Cannot resolve forest root DNS name from $forestRootNc. Exit." -TypeName 'Error' -ForegroundColor Red
            return
        }

        # KDS anchor MUST be forest root PDC
        if (-not $script:DomainAnchors.ContainsKey($forestRootDomain)) {
            Write-IdentIRLog -Message "No ONLINE PDC for forest root '$forestRootDomain' in IsolatedDCList. Add the forest root PDC and retry. Exit." -TypeName 'Error' -ForegroundColor Red
            return
        }

        $script:kdsBindServer = $script:DomainAnchors[$forestRootDomain]
        Write-IdentIRLog -Message "Forest root: $forestRootDomain (KDS anchor: $($script:kdsBindServer))" -TypeName 'Info' -ForegroundColor Cyan

        # Get config NC from forest-root PDC
        $script:cfgNC = (& $GetDe ("LDAP://$($script:kdsBindServer)/RootDSE")).Properties['configurationNamingContext'][0]

        # Read existing KDS root keys from forest-root PDC (no fallback)
        try {
            $keys = Get-KdsRootKeys -BindServer $script:kdsBindServer -GetDe $GetDe
            $script:existingKeyCount = $keys.Count
            $script:oldKeys          = $keys
            if ($keys.Count -gt 0) {
                Write-IdentIRLog -Message ("KDS keys on $($script:kdsBindServer): $($keys.Count)") -TypeName 'Info' -ForegroundColor Green
            } else {
                Write-IdentIRLog -Message ("No KDS keys on $($script:kdsBindServer). First key will be created.") -TypeName 'Info' -ForegroundColor Yellow
            }
        } catch {
            Write-IdentIRLog -Message "Cannot read KDS root keys on $($script:kdsBindServer): $($_.Exception.Message). Exit." -TypeName 'Error' -ForegroundColor Red
            return
        }

        # Create new KDS root key (on forest-root PDC only)
        if ($whatIf) {
            $effLabel = if ($script:DesiredUsableTime -le (Get-Date)) {
                "EffectiveImmediately"
            } else {
                "EffectiveTime=$($script:DesiredUsableTime)"
            }
            & $WI ("Create new KDS root key on $($script:kdsBindServer) ($effLabel)")
        } else {
            $creationOk = $true
            try {
                Write-IdentIRLog -Message "Creating new KDS root key on $($script:kdsBindServer)..." -TypeName 'Info' -ForegroundColor Cyan
                $cmd = Get-Command -Name Add-KdsRootKey -ErrorAction SilentlyContinue
                if ($cmd -and $cmd.Parameters.ContainsKey('DomainController')) {
                    Add-KdsRootKey -DomainController $script:kdsBindServer -EffectiveTime $script:KdsEffectiveTime | Out-Null
                } else {
                    $sb = { param($time) Add-KdsRootKey -EffectiveTime $time | Out-Null }
                    Invoke-Command -ComputerName $script:kdsBindServer -ScriptBlock $sb -ArgumentList $script:KdsEffectiveTime -ErrorAction Stop
                }
            } catch {
                $creationOk = $false
                Write-IdentIRLog -Message "KDS root key creation failed on $($script:kdsBindServer): $($_.Exception.Message)" -TypeName 'Error' -ForegroundColor Red
            }

            if (-not $creationOk) {
                Write-IdentIRLog -Message "KDS step failed. Fix forest root PDC / KDS and rerun. Exit." -TypeName 'Error' -ForegroundColor Red
                return
            }

            Write-IdentIRLog -Message "New KDS root key requested on $($script:kdsBindServer)" -TypeName 'Info' -ForegroundColor Green
            Force-ConfigReplication -SourceDC $script:kdsBindServer -CfgNC $script:cfgNC

            # Wait until new key is visible and capture CN
            $keyTimeout = (Get-Date).AddSeconds(180)
            do {
                Start-Sleep -Seconds 3
                $afterKeys = Get-KdsRootKeys -BindServer $script:kdsBindServer -GetDe $GetDe
                $newKey = $afterKeys |
                    Where-Object { $_.CN -notin $script:oldKeys.CN } |
                    Sort-Object WhenCreated -Descending |
                    Select-Object -First 1
                $script:newKdsCn = $newKey.CN
            } until ($script:newKdsCn -or (Get-Date) -gt $keyTimeout)

            if (-not $script:newKdsCn) {
                Write-IdentIRLog -Message "New KDS root key not visible on $($script:kdsBindServer) after timeout. Exit." -TypeName 'Error' -ForegroundColor Red
                return
            } else {
                Write-IdentIRLog -Message "New KDS key ready: $($script:newKdsCn)" -TypeName 'Info' -ForegroundColor Green
            }

            Restart-KdsService -ComputerName $script:kdsBindServer -WhatIfLocal:$whatIf
        }

        # expose for end{}
        $validated      = $script:validated
        $orderedDomains = $script:orderedDomains
        $meta           = $script:meta
        $GetDe          = $script:GetDe
        $whatIf         = $script:whatIf
        $newKdsCn       = $script:newKdsCn
    }

    process { }

    end {
        foreach ($domain in $script:orderedDomains) {

            $anchorKey = $domain.ToLower()
            if (-not $script:DomainAnchors.ContainsKey($anchorKey)) {
                Write-IdentIRLog -Message "Skip $domain: no ONLINE PDC (required for safe operation)." -TypeName 'Warning' -ForegroundColor Yellow
                continue
            }

            $bindServer = $script:DomainAnchors[$anchorKey]

            $dcs = @($script:validated | Where-Object { $_.Domain -ieq $domain -and $_.Online })
            if ($dcs -and $dcs[0].PSObject.Properties['IsRODC']) {
                $dcs = @($dcs | Where-Object { -not $_.IsRODC })
            }
            if (-not $dcs) {
                Write-IdentIRLog -Message "No ONLINE writable DCs for $domain. Skip." -TypeName 'Error' -ForegroundColor Red
                continue
            }

            $orderedDcs = @()
            $orderedDcs += @($dcs | Where-Object { $_.IsPdcRoleOwner })
            $orderedDcs += @($dcs | Where-Object { -not $_.IsPdcRoleOwner })

            $domainDn   = $script:meta[$domain].DefaultNC
            $domainFqdn = $script:meta[$domain].Domain

            Write-IdentIRLog -Message "Domain $domain – using PDC $bindServer" -TypeName 'Info' -ForegroundColor Cyan

            # Restart kdsSvc on domain DCs (parallel)
            if ($whatIf) {
                foreach ($c in ($orderedDcs | ForEach-Object { $_.FQDN } | Sort-Object -Unique)) {
                    & $WI ("Restart kdsSvc on $c")
                }
            } else {
                $targets = ($orderedDcs | ForEach-Object { $_.FQDN } | Sort-Object -Unique)
                $iss  = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                $pool = [RunspaceFactory]::CreateRunspacePool(1, 16, $iss, $Host)
                $pool.Open()
                $rsJobs = @()

                foreach ($t in $targets) {
                    $ps = [PowerShell]::Create()
                    $ps.RunspacePool = $pool
                    $null = $ps.AddScript({
                        param($ComputerName)
                        try {
                            $c = @{
                                ClassName    = 'Win32_Service'
                                Filter       = "Name='kdsSvc'"
                                ComputerName = $ComputerName
                            }
                            $svc = Get-CimInstance @c
                            if (-not $svc) { return @{Computer=$ComputerName; Success=$false; Error='kdsSvc not found'} }

                            $null = $svc | Invoke-CimMethod -MethodName StopService
                            $deadline = (Get-Date).AddSeconds(60)
                            while ($svc.State -ne 'Stopped' -and (Get-Date) -lt $deadline) {
                                $svc = Get-CimInstance @c
                                Start-Sleep -Milliseconds 200
                            }
                            if ($svc.State -ne 'Stopped') { return @{Computer=$ComputerName; Success=$false; Error='Stop timed out'} }

                            $null = $svc | Invoke-CimMethod -MethodName StartService
                            $deadline = (Get-Date).AddSeconds(60)
                            while ($svc.State -ne 'Running' -and (Get-Date) -lt $deadline) {
                                $svc = Get-CimInstance @c
                                Start-Sleep -Milliseconds 200
                            }
                            if ($svc.State -ne 'Running') { return @{Computer=$ComputerName; Success=$false; Error='Start timed out'} }

                            return @{Computer=$ComputerName; Success=$true}
                        } catch {
                            return @{Computer=$ComputerName; Success=$false; Error=$_.Exception.Message}
                        }
                    }).AddArgument($t)
                    $rsJobs += [pscustomobject]@{PS=$ps;Handle=$ps.BeginInvoke()}
                }

                foreach ($j in $rsJobs) {
                    try { $r = $j.PS.EndInvoke($j.Handle) } finally { $j.PS.Dispose() }
                    foreach ($x in $r) {
                        if ($x.Success) {
                            Write-IdentIRLog -Message "kdsSvc restarted on $($x.Computer)" -TypeName 'Info' -ForegroundColor Green
                        } else {
                            Write-IdentIRLog -Message "kdsSvc restart failed on $($x.Computer): $($x.Error)" -TypeName 'Warning' -ForegroundColor Yellow
                        }
                    }
                }
                $pool.Close()
                $pool.Dispose()
            }

            # Enumerate gMSAs in domain (pinned to PDC)
            $gmsaIndex = New-Object System.Collections.Generic.List[psobject]
            try {
                $root = & $script:GetDe ("LDAP://${bindServer}/${domainDn}")
                $ds = New-Object System.DirectoryServices.DirectorySearcher($root)
                $ds.PageSize = 1000
                $ds.Filter   = '(objectClass=msDS-GroupManagedServiceAccount)'
                $ds.PropertiesToLoad.AddRange(@('distinguishedName','sAMAccountName')) | Out-Null
                foreach ($r in $ds.FindAll()) {
                    $dn = $r.Properties['distinguishedname'][0]
                    $parent = if ($dn -and $dn.Contains(',')) { $dn.Substring($dn.IndexOf(',')+1) } else { $null }
                    $sam = if ($r.Properties['samaccountname']) { $r.Properties['samaccountname'][0] } else { $null }
                    $gmsaIndex.Add([pscustomobject]@{
                        DistinguishedName = $dn
                        ParentContainerDN = $parent
                        SamAccountName    = $sam
                    })
                }
            } catch {
                Write-IdentIRLog -Message "gMSA search failed in $domainDn via $bindServer: $($_.Exception.Message)" -TypeName 'Error' -ForegroundColor Red
            }

            Write-IdentIRLog -Message ("gMSAs in $domain: {0}" -f $gmsaIndex.Count) -TypeName 'Info' -ForegroundColor Green

            # Disable & tag → clear SPNs/DNS → delete → confirm → recreate
            $oldToNewMap = @{}
            $firstNewDn  = $null

            foreach ($g in $gmsaIndex) {

                $oldDn  = $g.DistinguishedName
                $parent = $g.ParentContainerDN
                $cn     = ($oldDn -split ',',2)[0] -replace '^CN='
                $sam    = $g.SamAccountName

                # backup attributes
                $exp = @{
                    DisplayName                         = $null
                    Description                         = $null
                    ServicePrincipalName                = @()
                    ManagedPasswordInterval             = 30
                    AllowedToDelegateTo                 = @()
                    UserAccountControl                  = $null
                    DnsHostName                         = $null
                    GroupMSAMembership                  = $null
                    AllowedToActOnBehalfOfOtherIdentity = $null
                    SupportedEncryptionTypes            = $null
                }

                try {
                    $xde = & $script:GetDe ("LDAP://${bindServer}/${oldDn}")
                    if ($xde.Properties['displayName'])                          { $exp.DisplayName     = $xde.Properties['displayName'][0] }
                    if ($xde.Properties['description'])                          { $exp.Description     = $xde.Properties['description'][0] }
                    if ($xde.Properties['servicePrincipalName'])                 { $exp.ServicePrincipalName = @($xde.Properties['servicePrincipalName']) }
                    if ($xde.Properties['msDS-ManagedPasswordInterval'])         { $exp.ManagedPasswordInterval = [int]$xde.Properties['msDS-ManagedPasswordInterval'][0] }
                    if ($xde.Properties['msDS-AllowedToDelegateTo'])             { $exp.AllowedToDelegateTo    = @($xde.Properties['msDS-AllowedToDelegateTo']) }
                    if ($xde.Properties['userAccountControl'])                   { $exp.UserAccountControl      = [int]$xde.Properties['userAccountControl'][0] }
                    if ($xde.Properties['dnsHostName'])                          { $exp.DnsHostName             = $xde.Properties['dnsHostName'][0] }
                    if ($xde.Properties['msDS-GroupMSAMembership'])              { $exp.GroupMSAMembership      = $xde.Properties['msDS-GroupMSAMembership'][0] }
                    if ($xde.Properties['msDS-AllowedToActOnBehalfOfOtherIdentity']) { $exp.AllowedToActOnBehalfOfOtherIdentity = $xde.Properties['msDS-AllowedToActOnBehalfOfOtherIdentity'][0] }
                    if ($xde.Properties['msDS-SupportedEncryptionTypes'])        { $exp.SupportedEncryptionTypes = [int]$xde.Properties['msDS-SupportedEncryptionTypes'][0] }
                } catch {
                    Write-IdentIRLog -Message "Read attributes failed for $oldDn: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                }

                Write-IdentIRLog -Message "Backup $oldDn (dns=$($exp.DnsHostName), SPNs=$($exp.ServicePrincipalName -join ', '))" -TypeName 'Info' -ForegroundColor Green

                # 1) Disable & tag OLD
                if ($whatIf) {
                    & $WI ("Disable + tag $oldDn")
                } else {
                    try {
                        $de  = & $script:GetDe ("LDAP://${bindServer}/${oldDn}")
                        $uac = [int]($de.Properties['userAccountControl'].Value)
                        $de.Properties['userAccountControl'].Value = ($uac -bor 0x2) # ACCOUNTDISABLE

                        $oldDesc = if ($de.Properties['description']) { $de.Properties['description'][0] } else { $null }
                        $newDesc = if ($oldDesc) { "$oldDesc [$CleanupTag]" } else { $CleanupTag }
                        $de.Properties['description'].Value      = $newDesc
                        $de.Properties['adminDescription'].Value = $CleanupTag

                        $de.SetInfo()
                        Write-IdentIRLog -Message "Disabled + tagged $oldDn" -TypeName 'Info' -ForegroundColor Green
                    } catch {
                        Write-IdentIRLog -Message "Disable/tag failed for $oldDn: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                    }
                }

                # 2) Clear SPNs & DNS on OLD
                if ($whatIf) {
                    & $WI ("Clear SPNs + dnsHostName on $oldDn")
                } else {
                    try {
                        $de = & $script:GetDe ("LDAP://${bindServer}/${oldDn}")
                        $de.Properties['servicePrincipalName'].Clear()
                        $de.Properties['dnsHostName'].Value = $null
                        $de.SetInfo()
                        Write-IdentIRLog -Message "Cleared SPNs + dnsHostName on $oldDn" -TypeName 'Info' -ForegroundColor Green
                    } catch {
                        Write-IdentIRLog -Message "Clear SPNs/DNS failed for $oldDn: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                    }
                }

                if (-not $whatIf) { Start-Sleep -Seconds 3 }

                # 3) Delete OLD
                if ($whatIf) {
                    & $WI ("Delete $oldDn")
                } else {
                    try {
                        $parentDn = $oldDn.Substring($oldDn.IndexOf(',')+1)
                        $pde      = & $script:GetDe ("LDAP://${bindServer}/${parentDn}")
                        $pde.Delete("msDS-GroupManagedServiceAccount","CN=$cn")
                        Write-IdentIRLog -Message "Deleted $oldDn" -TypeName 'Info' -ForegroundColor Green
                    } catch {
                        Write-IdentIRLog -Message "Delete failed for $oldDn: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                        continue
                    }
                    Start-Sleep -Seconds 3
                }

                # 4) Confirm CN gone
                $ou     = & $script:GetDe ("LDAP://${bindServer}/${parent}")
                $exists = $false
                if (-not $whatIf) {
                    $exists     = $true
                    $retryCount = 0
                    $maxRetries = 20
                    while ($exists -and $retryCount -lt $maxRetries) {
                        $exists = $false
                        try {
                            $dsCheck = New-Object System.DirectoryServices.DirectorySearcher($ou)
                            $dsCheck.Filter      = "(cn=$cn)"
                            $dsCheck.SearchScope = 'OneLevel'
                            $dsCheck.PageSize    = 1
                            if ($dsCheck.FindOne()) { $exists = $true }
                        } catch {
                            Write-IdentIRLog -Message "CN check failed for $cn in $parent: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                        }
                        if ($exists) { Start-Sleep -Seconds 5 }
                        $retryCount++
                    }
                }
                if ($exists) {
                    Write-IdentIRLog -Message "CN $cn still exists after retries. Skip recreate to avoid LDAP errors." -TypeName 'Warning' -ForegroundColor Yellow
                    continue
                }

                # Normalize sAM (end with $; <=15 chars)
                if ($sam -and -not $sam.EndsWith('$')) { $sam = "${sam}$" }
                if ($sam -and $sam.Length -gt 15) {
                    $oldSam = $sam
                    $sam    = $sam.Substring(0,15)
                    Write-IdentIRLog -Message "sAM '$oldSam' → '$sam' (15-char limit)" -TypeName 'Warning' -ForegroundColor Yellow
                }

                # Generate dnsHostName if missing
                if (-not $exp.DnsHostName) {
                    $exp.DnsHostName = "$cn.$domainFqdn"
                    Write-IdentIRLog -Message "Set dnsHostName for $cn,$parent to $($exp.DnsHostName)" -TypeName 'Info' -ForegroundColor Cyan
                }

                # 5) Recreate NEW
                $newDn = $null
                if ($whatIf) {
                    & $WI ("Create CN=$cn,$parent")
                } else {
                    try {
                        $new = $ou.Create("msDS-GroupManagedServiceAccount", "CN=$cn")

                        if ($sam)                 { $new.Put("sAMAccountName", $sam) }
                        if ($exp.DisplayName)     { $new.Put("displayName", $exp.DisplayName) }
                        if ($exp.Description)     { $new.Put("description", $exp.Description) }
                        $new.Put("msDS-ManagedPasswordInterval", $exp.ManagedPasswordInterval)

                        $uac = if ($exp.UserAccountControl) { [int]$exp.UserAccountControl } else { 0x1000 } # WORKSTATION_TRUST_ACCOUNT
                        $uac = ($uac -band (-bnot 0x2)) # ensure enabled
                        $new.Put("userAccountControl", $uac)

                        if ($exp.DnsHostName)        { $new.Put("dnsHostName", $exp.DnsHostName) }
                        if ($exp.GroupMSAMembership)  { $new.Put("msDS-GroupMSAMembership", $exp.GroupMSAMembership) }
                        if ($null -ne $exp.SupportedEncryptionTypes) { $new.Put("msDS-SupportedEncryptionTypes", $exp.SupportedEncryptionTypes) }

                        $new.Properties['adminDescription'].Value = 'Restored'

                        # First commit core attributes
                        $new.SetInfo()

                        # Second stage: SPNs / delegation / AOB
                        try {
                            foreach ($spn in @($exp.ServicePrincipalName)) {
                                [void]$new.Properties["servicePrincipalName"].Add($spn)
                            }
                        } catch {
                            Write-IdentIRLog -Message "Add SPNs failed for $cn,$parent: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                        }

                        try {
                            foreach ($svc in @($exp.AllowedToDelegateTo)) {
                                [void]$new.Properties["msDS-AllowedToDelegateTo"].Add($svc)
                            }
                        } catch {
                            Write-IdentIRLog -Message "Add AllowedToDelegateTo failed for $cn,$parent: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                        }

                        try {
                            if ($exp.AllowedToActOnBehalfOfOtherIdentity) {
                                $new.Properties['msDS-AllowedToActOnBehalfOfOtherIdentity'].Value = $exp.AllowedToActOnBehalfOfOtherIdentity
                            }
                        } catch {
                            Write-IdentIRLog -Message "Restore AllowedToActOnBehalfOfOtherIdentity failed for $cn,$parent: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                        }

                        try {
                            $new.SetInfo()
                        } catch {
                            $e = $_.Exception
                            $detail = if ($e -is [System.DirectoryServices.DirectoryServicesCOMException] -and $e.ExtendedErrorMessage) {
                                $e.ExtendedErrorMessage.Trim()
                            } else {
                                $e.Message
                            }
                            Write-IdentIRLog -Message "Final SetInfo failed for $cn,$parent: $detail" -TypeName 'Warning' -ForegroundColor Yellow
                        }

                        $newDn = "CN=$cn,$parent"
                        Write-IdentIRLog -Message "Created new gMSA: $newDn" -TypeName 'Info' -ForegroundColor Green

                    } catch {
                        $e = $_.Exception
                        $detail = if ($e -is [System.DirectoryServices.DirectoryServicesCOMException] -and $e.ExtendedErrorMessage) {
                            $e.ExtendedErrorMessage.Trim()
                        } else {
                            $e.Message
                        }
                        Write-IdentIRLog -Message "Create gMSA failed (CN=$cn,$parent): $detail" -TypeName 'Error' -ForegroundColor Red
                    }
                }

                if ($newDn) {
                    $oldToNewMap[$oldDn] = $newDn
                    if (-not $firstNewDn) { $firstNewDn = $newDn }
                }
            }

            # Optional host rebind
            if ($RebindHosts -and $oldToNewMap.Count -gt 0) {
                if ($whatIf) {
                    & $WI ("Rebind hosts (map count: $($oldToNewMap.Count)) in $domain")
                } else {
                    try {
                        $root = & $script:GetDe ("LDAP://${bindServer}/${domainDn}")
                        $ds = New-Object System.DirectoryServices.DirectorySearcher($root)
                        $ds.PageSize = 1000
                        $ds.Filter   = '(&(objectCategory=computer)(msDS-HostServiceAccount=*))'
                        $ds.PropertiesToLoad.AddRange(@('distinguishedName','msDS-HostServiceAccount')) | Out-Null
                        $reboundCount = 0
                        foreach ($r in $ds.FindAll()) {
                            $compDn = $r.Properties['distinguishedname'][0]
                            $currentAccounts = @($r.Properties['msds-hostserviceaccount'])
                            $updated = $false
                            for ($i = 0; $i -lt $currentAccounts.Count; $i++) {
                                if ($oldToNewMap.ContainsKey($currentAccounts[$i])) {
                                    $currentAccounts[$i] = $oldToNewMap[$currentAccounts[$i]]
                                    $updated = $true
                                }
                            }
                            if ($updated) {
                                try {
                                    $cde = & $script:GetDe ("LDAP://${bindServer}/${compDn}")
                                    $cde.Properties['msDS-HostServiceAccount'].Clear()
                                    foreach ($acc in $currentAccounts) {
                                        [void]$cde.Properties['msDS-HostServiceAccount'].Add($acc)
                                    }
                                    $cde.SetInfo()
                                    Write-IdentIRLog -Message "Rebound host $compDn" -TypeName 'Info' -ForegroundColor White
                                    $reboundCount++
                                } catch {
                                    Write-IdentIRLog -Message "Rebind failed for $compDn: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                                }
                            }
                        }
                        Write-IdentIRLog -Message "Rebound $reboundCount host(s) in $domain" -TypeName 'Info' -ForegroundColor Green
                    } catch {
                        Write-IdentIRLog -Message "Host rebind query failed in $domainDn via $bindServer: $($_.Exception.Message)" -TypeName 'Error' -ForegroundColor Red
                    }
                }
            }

            # Verify new KDS usage (execution only). GUID starts at offset 24.
            if (-not $whatIf -and $gmsaIndex.Count -gt 0 -and $firstNewDn -and $newKdsCn) {
                try {
                    Start-Sleep -Seconds 2
                    $nde = & $script:GetDe ("LDAP://${bindServer}/${firstNewDn}")
                    $bytes = $nde.Properties['msDS-ManagedPasswordId'].Value
                    if ($bytes -and $bytes.Length -ge 40) {
                        [byte[]]$guidBytes = $bytes[24..39]
                        $extractedGuid = New-Object Guid -ArgumentList (,$guidBytes)
                        $extractedStr  = $extractedGuid.ToString()
                        if ($extractedStr -eq $newKdsCn) {
                            Write-IdentIRLog -Message "Verified $firstNewDn uses new KDS key $newKdsCn" -TypeName 'Info' -ForegroundColor Green
                        } else {
                            Write-IdentIRLog -Message "KDS verify mismatch on $firstNewDn (has $extractedStr, expected $newKdsCn)" -TypeName 'Error' -ForegroundColor Red
                        }
                    } else {
                        Write-IdentIRLog -Message "No valid msDS-ManagedPasswordId on $firstNewDn for KDS verify" -TypeName 'Warning' -ForegroundColor Yellow
                    }
                } catch {
                    Write-IdentIRLog -Message "KDS verify failed on $firstNewDn: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                }
            }

            Write-IdentIRLog -Message "Domain $domain done" -TypeName 'Info' -ForegroundColor White
        }

        if ($whatIf) {
            Write-IdentIRLog -Message "Simulation complete (WhatIf=True)." -TypeName 'Info' -ForegroundColor White
            return
        }

        # Old KDS key cleanup if we created a new one earlier
        if ($script:existingKeyCount -gt 0 -and $script:newKdsCn) {
            try {
                $deleted = Remove-KdsRootKeys -BindServer $script:kdsBindServer -GetDe $script:GetDe -OldKeys $script:oldKeys -WhatIfLocal:$whatIf
                if ($deleted -gt 0) {
                    Write-IdentIRLog -Message "Deleted $deleted old KDS root key(s) on $($script:kdsBindServer)" -TypeName 'Info' -ForegroundColor Yellow
                } else {
                    Write-IdentIRLog -Message "No old KDS keys deleted on $($script:kdsBindServer)" -TypeName 'Info' -ForegroundColor White
                }
                Force-ConfigReplication -SourceDC $script:kdsBindServer -CfgNC $script:cfgNC
            } catch {
                Write-IdentIRLog -Message "Old KDS key cleanup failed on $($script:kdsBindServer): $($_.Exception.Message)" -TypeName 'Error' -ForegroundColor Red
            }
        }

        # Final kdsSvc restart on all ONLINE DCs (parallel)
        $allDcs = $script:validated | Where-Object { $_.Online } | ForEach-Object { $_.FQDN } | Sort-Object -Unique
        if ($whatIf) {
            foreach ($c in $allDcs) { & $WI ("Restart kdsSvc on $c") }
        } else {
            $issF  = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
            $poolF = [RunspaceFactory]::CreateRunspacePool(1, 16, $issF, $Host)
            $poolF.Open()
            $jobsF = @()
            foreach ($c in $allDcs) {
                $ps = [PowerShell]::Create()
                $ps.RunspacePool = $poolF
                $null = $ps.AddScript({
                    param($ComputerName)
                    try {
                        $c = @{
                            ClassName    = 'Win32_Service'
                            Filter       = "Name='kdsSvc'"
                            ComputerName = $ComputerName
                        }
                        $svc = Get-CimInstance @c
                        if (-not $svc) { return @{Computer=$ComputerName; Success=$false; Error='kdsSvc not found'} }

                        $null = $svc | Invoke-CimMethod -MethodName StopService
                        $deadline = (Get-Date).AddSeconds(60)
                        while ($svc.State -ne 'Stopped' -and (Get-Date) -lt $deadline) {
                            $svc = Get-CimInstance @c
                            Start-Sleep -Milliseconds 200
                        }
                        if ($svc.State -ne 'Stopped') { return @{Computer=$ComputerName; Success=$false; Error='Stop timed out'} }

                        $null = $svc | Invoke-CimMethod -MethodName StartService
                        $deadline = (Get-Date).AddSeconds(60)
                        while ($svc.State -ne 'Running' -and (Get-Date) -lt $deadline) {
                            $svc = Get-CimInstance @c
                            Start-Sleep -Milliseconds 200
                        }
                        if ($svc.State -ne 'Running') { return @{Computer=$ComputerName; Success=$false; Error='Start timed out'} }

                        return @{Computer=$ComputerName; Success=$true}
                    } catch {
                        return @{Computer=$ComputerName; Success=$false; Error=$_.Exception.Message}
                    }
                }).AddArgument($c)
                $jobsF += [pscustomobject]@{PS=$ps;Handle=$ps.BeginInvoke()}
            }

            foreach ($j in $jobsF) {
                try { $r = $j.PS.EndInvoke($j.Handle) } finally { $j.PS.Dispose() }
                foreach ($x in $r) {
                    if ($x.Success) {
                        Write-IdentIRLog -Message "kdsSvc restarted on $($x.Computer)" -TypeName 'Info' -ForegroundColor Green
                    } else {
                        Write-IdentIRLog -Message "kdsSvc restart failed on $($x.Computer): $($x.Error)" -TypeName 'Warning' -ForegroundColor Yellow
                    }
                }
            }
            $poolF.Close()
            $poolF.Dispose()
        }

        Write-IdentIRLog -Message "Set-GMSA completed." -TypeName 'Info' -ForegroundColor White
    }
}
