<#
.SYNOPSIS
Recreates and rotates all gMSA accounts and KDS root keys across isolated domains.

.DESCRIPTION
Set-GMSA validates ONLINE writable DCs, orders Forest Root -> Child -> Tree Root, and creates a new KDS root key
(effective now or offset). It restarts kdsSvc on all DCs, disables and removes existing gMSAs, then recreates
them with restored attributes. Optionally rebinds computers msDS-HostServiceAccount entries. Deletes old
KDS keys after replication. Runs in WhatIf unless -Execute is supplied.

.PARAMETER IsolatedDCList
DC inventory objects with at least: FQDN, Domain, DefaultNamingContext, Type, IsPdcRoleOwner, Online.

.PARAMETER CleanupTag
String tag placed in adminDescription of old gMSAs (default: 'cleanup-gmsa').

.PARAMETER RebindHosts
When used, rebinds computers to recreated gMSAs.

.PARAMETER Execute
Apply changes; omit to simulate (WhatIf=True).

.PARAMETER EffectiveImmediately
Create KDS key effective immediately (default).

.PARAMETER EffectiveTimeHoursOffset
Offset in hours for new KDS key usability (default 0).

.EXAMPLE
# Simulate full gMSA rotation
Set-GMSA -IsolatedDCList $dcs

.EXAMPLE
# Apply with host rebinding
Set-GMSA -IsolatedDCList $dcs -RebindHosts -Execute

.OUTPUTS
None. Progress logged via Write-IdentIRLog.

.NOTES
Author: NightCityShogun
Version: 1.2
Requires: Add-KdsRootKey, ADSI, CIM/WMI, Domain/Enterprise Admin privileges.
Behavior: Creates new KDS root key on forest-root PDC via CIM (Win32_Process), forces replication from that PDC via
repadmin started with CIM, restarts kdsSvc, recreates gMSAs, optionally rebinds hosts, removes old keys.
SupportsShouldProcess: True
(c) 2025 NightCityShogun. All rights reserved.
#>

function Set-GMSA {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory, ValueFromPipeline)]
        [AllowEmptyCollection()]
        [PSObject[]]$IsolatedDCList,

        [string]$CleanupTag = 'cleanup-gmsa',
        [switch]$RebindHosts,
        [switch]$Execute,

        # KDS timing (defaults keep current behavior)
        [switch]$EffectiveImmediately = $true,
        [int]$EffectiveTimeHoursOffset = 0
    )

    begin {
        $ErrorActionPreference = 'Stop'
        Set-StrictMode -Version Latest

        $doExec = [bool]$Execute
        $whatIf = -not $doExec

        # --- helpers ---
        $GetDe = { param([string]$Path) [ADSI]$Path }

        $WI = {
            param([string]$Message)
            if ($whatIf) {
                Write-IdentIRLog -Message "[WHATIF] $Message" -TypeName 'Info' -ForegroundColor Green
            }
        }

        function Get-KdsRootKeys {
            param(
                [string]$BindServer,
                [scriptblock]$GetDe
            )

            $keys = New-Object System.Collections.Generic.List[psobject]
            try {
                $rootDse = & $GetDe ("LDAP://$BindServer/RootDSE")
                $cfgNC   = $rootDse.Properties['configurationNamingContext'][0]
                $kdsPath = "LDAP://$BindServer/CN=Master Root Keys,CN=Group Key Distribution Service,CN=Services,$cfgNC"
                $searchRoot = & $GetDe $kdsPath

                $ds = New-Object System.DirectoryServices.DirectorySearcher($searchRoot)
                $ds.Filter      = '(objectClass=msKds-ProvRootKey)'
                $ds.PageSize    = 1000
                $ds.SearchScope = [System.DirectoryServices.SearchScope]::OneLevel
                $ds.PropertiesToLoad.AddRange(@('distinguishedName','cn','whenCreated')) | Out-Null

                foreach ($r in $ds.FindAll()) {
                    $dn = $r.Properties['distinguishedname'][0]
                    $cn = $r.Properties['cn'][0]
                    $wc = if ($r.Properties['whencreated']) { [datetime]$r.Properties['whencreated'][0] } else { $null }

                    $keys.Add([pscustomobject]@{
                        DistinguishedName = $dn
                        CN                = $cn
                        WhenCreated       = $wc
                    })
                }
            } catch {
                Write-IdentIRLog -Message "KDS key query failed via ${BindServer}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
            }
            return ,$keys
        }

        function Remove-KdsRootKeys {
            param(
                [string]$BindServer,
                [scriptblock]$GetDe,
                [psobject[]]$OldKeys
            )

            $count = 0
            if (-not $OldKeys) { return 0 }

            try {
                $rootDse = & $GetDe ("LDAP://$BindServer/RootDSE")
                $cfgNC   = $rootDse.Properties['configurationNamingContext'][0]
                $kdsPath = "LDAP://$BindServer/CN=Master Root Keys,CN=Group Key Distribution Service,CN=Services,$cfgNC"
                $container = & $GetDe $kdsPath

                foreach ($key in $OldKeys) {
                    try {
                        $container.Delete("msKds-ProvRootKey", "CN=$($key.CN)")
                        $count++
                    } catch {
                        Write-IdentIRLog -Message "Failed to delete old KDS key CN=$($key.CN) via ${BindServer}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                    }
                }
            } catch {
                Write-IdentIRLog -Message "Old KDS key container access failed via ${BindServer}: $($_.Exception.Message)" -TypeName 'Error' -ForegroundColor Red
            }
            return $count
        }

        function Restart-KdsService {
            param([string]$ComputerName)

            if ($whatIf) {
                & $WI ("Restart kdsSvc on $ComputerName")
                return
            }

            try {
                $c = @{
                    ClassName    = 'Win32_Service'
                    Filter       = "Name='kdsSvc'"
                    ComputerName = $ComputerName
                }

                $svc = Get-CimInstance @c
                if (-not $svc) {
                    Write-IdentIRLog -Message "kdsSvc not found on $ComputerName" -TypeName 'Warning' -ForegroundColor Yellow
                    return
                }

                $null = $svc | Invoke-CimMethod -MethodName StopService | Out-Null
                $deadline = (Get-Date).AddSeconds(60)
                while ($svc.State -ne 'Stopped' -and (Get-Date) -lt $deadline) {
                    $svc = Get-CimInstance @c
                    Start-Sleep -Milliseconds 200
                }
                if ($svc.State -ne 'Stopped') {
                    Write-IdentIRLog -Message "kdsSvc stop timed out on $ComputerName" -TypeName 'Warning' -ForegroundColor Yellow
                }

                $null = $svc | Invoke-CimMethod -MethodName StartService | Out-Null
                $deadline = (Get-Date).AddSeconds(60)
                while ($svc.State -ne 'Running' -and (Get-Date) -lt $deadline) {
                    $svc = Get-CimInstance @c
                    Start-Sleep -Milliseconds 200
                }
                if ($svc.State -ne 'Running') {
                    Write-IdentIRLog -Message "kdsSvc start timed out on $ComputerName" -TypeName 'Warning' -ForegroundColor Yellow
                }

                Write-IdentIRLog -Message "kdsSvc restarted on $ComputerName" -TypeName 'Info' -ForegroundColor Green
            } catch {
                Write-IdentIRLog -Message "kdsSvc restart failed on ${ComputerName}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
            }
        }

        function Force-ConfigReplication {
            param(
                [string]$SourceDC,
                [string]$CfgNC
            )

            # IMPORTANT: repadmin MUST run on forest-root PDC.
            if ($whatIf) {
                & $WI ("repadmin /syncall $SourceDC $CfgNC /d /e /P (started remotely via CIM Win32_Process)")
                return
            }

            try {
                $cmd = "repadmin.exe /syncall $SourceDC $CfgNC /d /e /P"
                $result = Invoke-CimMethod -ClassName Win32_Process -ComputerName $SourceDC -MethodName Create -Arguments @{ CommandLine = $cmd }

                if ($result.ReturnValue -ne 0) {
                    Write-IdentIRLog -Message "Config replication launch failed on $SourceDC via CIM (Win32_Process.Create=$($result.ReturnValue))." -TypeName 'Warning' -ForegroundColor Yellow
                } else {
                    Write-IdentIRLog -Message "Config replication triggered on $SourceDC via repadmin (PID=$($result.ProcessId))." -TypeName 'Info' -ForegroundColor Green
                }
            } catch {
                Write-IdentIRLog -Message "Config replication failed from $SourceDC via CIM: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
            }
        }

        function Invoke-AddKdsRootKeyRemote {
            param(
                [string]$ComputerName,
                [datetime]$EffectiveTime
            )

            # IMPORTANT: KDS key MUST be created on forest-root PDC.
            if ($whatIf) {
                & $WI ("Add-KdsRootKey on $ComputerName (EffectiveTime=$EffectiveTime)")
                return $true
            }

            try {
                $iso = $EffectiveTime.ToString("o")

                # Use a PowerShell one-liner that:
                #  - imports the Kds module explicitly
                #  - parses the ISO time
                #  - calls Add-KdsRootKey
                $ps = @"
Import-Module Kds -ErrorAction Stop
[datetime]`$t = [datetime]::ParseExact('$iso','o',[System.Globalization.CultureInfo]::InvariantCulture)
Add-KdsRootKey -EffectiveTime `$t
"@

                $cmd = "powershell.exe -NoProfile -NonInteractive -Command `"$ps`""

                $result = Invoke-CimMethod -ClassName Win32_Process -ComputerName $ComputerName -MethodName Create -Arguments @{ CommandLine = $cmd }

                if ($result.ReturnValue -ne 0) {
                    Write-IdentIRLog -Message "Add-KdsRootKey remote launch failed on $ComputerName (Win32_Process.Create=$($result.ReturnValue))." -TypeName 'Error' -ForegroundColor Red
                    return $false
                }

                Write-IdentIRLog -Message "Add-KdsRootKey remotely started on $ComputerName (PID=$($result.ProcessId))." -TypeName 'Info' -ForegroundColor Green
                return $true
            } catch {
                Write-IdentIRLog -Message "Add-KdsRootKey remote execution failed on ${ComputerName}: $($_.Exception.Message)" -TypeName 'Error' -ForegroundColor Red
                return $false
            }
        }

        # --- validate DC list ---
        $in = @($IsolatedDCList)
        if (-not $in -or $in.Count -eq 0) {
            Write-IdentIRLog -Message "IsolatedDCList is empty." -TypeName 'Error' -ForegroundColor Red
            return
        }

        $validated = New-Object System.Collections.Generic.List[psobject]
        foreach ($dc in $in) {
            $required = @('FQDN','Domain','DefaultNamingContext','Type','IsPdcRoleOwner','Online')
            $missing = $required | Where-Object {
                -not $dc.PSObject.Properties[$_] -or
                $null -eq $dc.$_ -or
                ($dc.$_.ToString() -eq '')
            }

            if ($missing) {
                Write-IdentIRLog -Message "Invalid IsolatedDCList entry for $($dc.FQDN): Missing $($missing -join ', ')" -TypeName 'Warning' -ForegroundColor Yellow
                continue
            }
            $validated.Add($dc)
        }

        if (@($validated).Count -eq 0) {
            Write-IdentIRLog -Message "No valid DC entries." -TypeName 'Warning' -ForegroundColor Yellow
            return
        }

        # Single forest check
        $forestRoots = New-Object System.Collections.Generic.HashSet[string]
        foreach ($dc in $validated | Where-Object { $_.Online }) {
            try {
                $rootDse = & $GetDe ("LDAP://$($dc.FQDN)/RootDSE")
                [void]$forestRoots.Add($rootDse.Properties['rootDomainNamingContext'][0])
            } catch {
                Write-IdentIRLog -Message "Failed to get rootDomainNamingContext from $($dc.FQDN): $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
            }
        }

        if ($forestRoots.Count -gt 1) {
            Write-IdentIRLog -Message "Multiple forests detected in input. This function supports one forest only." -TypeName 'Error' -ForegroundColor Red
            return
        }
        if ($forestRoots.Count -eq 0) {
            Write-IdentIRLog -Message "No forest root NC detected." -TypeName 'Error' -ForegroundColor Red
            return
        }

        $forestRootNc     = $forestRoots | Select-Object -First 1
        $forestRootDomain = ($forestRootNc -replace '^DC=', '' -replace ',DC=', '.').ToLower()

        # Determine forest-root PDC (hard requirement for KDS + repadmin)
        $forestRootDcCandidates = $validated | Where-Object {
            $_.DefaultNamingContext -eq $forestRootNc -and $_.Online
        }

        $forestRootPdc = $forestRootDcCandidates |
            Where-Object { $_.IsPdcRoleOwner } |
            Select-Object -First 1

        if (-not $forestRootPdc) {
            Write-IdentIRLog -Message "Forest root PDC for '$forestRootDomain' not found or offline. Aborting (KDS and repadmin must run on forest-root PDC)." -TypeName 'Error' -ForegroundColor Red
            return
        }

        $script:kdsBindServer = $forestRootPdc.FQDN
        Write-IdentIRLog -Message "Forest root PDC anchor: $($script:kdsBindServer)" -TypeName 'Info' -ForegroundColor Cyan

        # Domain ordering: Forest Root -> Child -> Tree Root
        $priority = @{ 'Forest Root' = 1; 'Child Domain' = 2; 'Tree Root' = 3 }
        $groups   = $validated | Group-Object -Property Domain
        $meta     = @{}

        foreach ($g in $groups) {
            $rep = $g.Group | Select-Object -First 1
            $meta[$g.Name] = @{
                Type      = $rep.Type
                DefaultNC = $rep.DefaultNamingContext
                Domain    = $g.Name
            }
        }

        $orderedDomains = ($groups.Name) | Sort-Object {
            if ($priority.ContainsKey($meta[$_].Type)) { $priority[$meta[$_].Type] } else { 4 }
        }, $_

        Write-IdentIRLog -Message ("gMSA rotation scope across {0} domain(s) (WhatIf={1})" -f @($orderedDomains).Count, $whatIf) -TypeName 'Info' -ForegroundColor Cyan

        # shared state
        $script:validated      = $validated
        $script:orderedDomains = $orderedDomains
        $script:meta           = $meta
        $script:GetDe          = $GetDe
        $script:whatIf         = $whatIf

        $script:DesiredUsableTime = if ([bool]$EffectiveImmediately -or ($EffectiveTimeHoursOffset -eq 0)) {
            Get-Date
        } else {
            (Get-Date).AddHours($EffectiveTimeHoursOffset)
        }

        $script:KdsEffectiveTime = $script:DesiredUsableTime.AddHours(-10)
        $script:newKdsCn         = $null

        # Use forest-root PDC RootDSE for cfgNC
        $script:cfgNC = (& $GetDe ("LDAP://$($script:kdsBindServer)/RootDSE")).Properties['configurationNamingContext'][0]

        # Capture existing KDS keys via forest-root PDC
        $existingKeys = Get-KdsRootKeys -BindServer $script:kdsBindServer -GetDe $GetDe
        $script:existingKeyCount = $existingKeys.Count
        $script:oldKeys          = $existingKeys

        if ($script:existingKeyCount -gt 0) {
            Write-IdentIRLog -Message ("Existing KDS keys on forest-root PDC: {0}" -f $script:existingKeyCount) -TypeName 'Info' -ForegroundColor Green
        } else {
            Write-IdentIRLog -Message "No existing KDS root keys found on forest-root PDC (first-time creation)." -TypeName 'Info' -ForegroundColor Cyan
        }

        # Create new KDS root key REMOTELY on forest-root PDC via CIM -> Win32_Process
        if ($whatIf) {
            $effLabel = if ($script:DesiredUsableTime -le (Get-Date)) {
                "EffectiveImmediately"
            } else {
                "EffectiveTime=$($script:DesiredUsableTime)"
            }
            & $WI ("Create new KDS root key on $($script:kdsBindServer) ($effLabel) via remote CIM Win32_Process")
        } else {
            $creationOk = Invoke-AddKdsRootKeyRemote -ComputerName $script:kdsBindServer -EffectiveTime $script:KdsEffectiveTime

            if (-not $creationOk) {
                Write-IdentIRLog -Message "KDS root key creation FAILED on $($script:kdsBindServer). Continuing with existing KDS keys only (no new key verification)." -TypeName 'Error' -ForegroundColor Red
            } else {
                Write-IdentIRLog -Message "New KDS root key requested on $($script:kdsBindServer)" -TypeName 'Info' -ForegroundColor Green

                # Force config replication from forest-root PDC ONLY
                Force-ConfigReplication -SourceDC $script:kdsBindServer -CfgNC $script:cfgNC

                # Wait until new key is visible and capture its CN
                $keyTimeout = (Get-Date).AddSeconds(180)
                do {
                    Start-Sleep -Seconds 3
                    $afterKeys = Get-KdsRootKeys -BindServer $script:kdsBindServer -GetDe $GetDe
                    $newKey = $afterKeys |
                        Where-Object { $_.CN -notin $script:oldKeys.CN } |
                        Sort-Object WhenCreated -Descending |
                        Select-Object -First 1

                    if ($newKey) { $script:newKdsCn = $newKey.CN }
                } until ($script:newKdsCn -or (Get-Date) -gt $keyTimeout)

                if (-not $script:newKdsCn) {
                    Write-IdentIRLog -Message "New KDS root key not visible on forest-root PDC after timeout. Proceeding with gMSA operations but skipping new-key verification and old-key deletion." -TypeName 'Error' -ForegroundColor Red
                } else {
                    Write-IdentIRLog -Message "New KDS root key visible on forest-root PDC: $($script:newKdsCn)" -TypeName 'Info' -ForegroundColor Green
                }
            }

            Restart-KdsService -ComputerName $script:kdsBindServer
        }

        # expose for end{}
        $validated      = $script:validated
        $orderedDomains = $script:orderedDomains
        $meta           = $script:meta
        $GetDe          = $script:GetDe
        $whatIf         = $script:whatIf
        $newKdsCn       = $script:newKdsCn
    }

    process { }

    end {
        foreach ($domain in $script:orderedDomains) {

            $dcs = @(
                $script:validated |
                Where-Object { $_.Domain -ieq $domain -and $_.Online }
            )

            if ($dcs -and $dcs[0].PSObject.Properties['IsRODC']) {
                $dcs = @($dcs | Where-Object { -not $_.IsRODC })
            }

            if (-not $dcs) {
                Write-IdentIRLog -Message "No online writable DCs for $domain. Skipping." -TypeName 'Error' -ForegroundColor Red
                continue
            }

            $orderedDcs = @()
            $orderedDcs += @($dcs | Where-Object { $_.IsPdcRoleOwner })
            $orderedDcs += @($dcs | Where-Object { -not $_.IsPdcRoleOwner })

            $bindServer = $orderedDcs[0].FQDN
            $domainDn   = $script:meta[$domain].DefaultNC
            $domainFqdn = $script:meta[$domain].Domain

            Write-IdentIRLog -Message "Starting gMSA Rotation Domain $domain (PDC anchor $bindServer)" -TypeName 'Info' -ForegroundColor Cyan

            # Restart kdssvc on domain DCs (parallel in Execute, simulated in WhatIf)
            if ($whatIf) {
                foreach ($c in ($orderedDcs | ForEach-Object { $_.FQDN } | Sort-Object -Unique)) {
                    & $WI ("Restart kdsSvc on $c")
                }
            } else {
                $targets = ($orderedDcs | ForEach-Object { $_.FQDN } | Sort-Object -Unique)
                $iss = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
                $pool = [RunspaceFactory]::CreateRunspacePool(1, 16, $iss, $Host)
                $pool.Open()
                $rsJobs = @()

                foreach ($t in $targets) {
                    $ps = [PowerShell]::Create()
                    $ps.RunspacePool = $pool
                    $null = $ps.AddScript({
                        param($ComputerName)
                        try {
                            $c = @{
                                ClassName    = 'Win32_Service'
                                Filter       = "Name='kdsSvc'"
                                ComputerName = $ComputerName
                            }
                            $svc = Get-CimInstance @c
                            if (-not $svc) { return @{Computer=$ComputerName; Success=$false; Error='kdsSvc not found'} }

                            $null = $svc | Invoke-CimMethod -MethodName StopService
                            $deadline = (Get-Date).AddSeconds(60)
                            while ($svc.State -ne 'Stopped' -and (Get-Date) -lt $deadline) {
                                $svc = Get-CimInstance @c
                                Start-Sleep -Milliseconds 200
                            }
                            if ($svc.State -ne 'Stopped') { return @{Computer=$ComputerName; Success=$false; Error='Stop timed out'} }

                            $null = $svc | Invoke-CimMethod -MethodName StartService
                            $deadline = (Get-Date).AddSeconds(60)
                            while ($svc.State -ne 'Running' -and (Get-Date) -lt $deadline) {
                                $svc = Get-CimInstance @c
                                Start-Sleep -Milliseconds 200
                            }
                            if ($svc.State -ne 'Running') { return @{Computer=$ComputerName; Success=$false; Error='Start timed out'} }

                            return @{Computer=$ComputerName; Success=$true}
                        } catch {
                            return @{Computer=$ComputerName; Success=$false; Error=$_.Exception.Message}
                        }
                    }).AddArgument($t)

                    $rsJobs += [pscustomobject]@{ PS = $ps; Handle = $ps.BeginInvoke() }
                }

                foreach ($j in $rsJobs) {
                    try {
                        $r = $j.PS.EndInvoke($j.Handle)
                    } finally {
                        $j.PS.Dispose()
                    }
                    foreach ($x in $r) {
                        if ($x.Success) {
                            Write-IdentIRLog -Message "kdsSvc restarted on $($x.Computer)" -TypeName 'Info' -ForegroundColor Green
                        } else {
                            Write-IdentIRLog -Message "kdsSvc restart failed on $($x.Computer): $($x.Error)" -TypeName 'Warning' -ForegroundColor Yellow
                        }
                    }
                }

                $pool.Close()
                $pool.Dispose()
            }

            # Enumerate gMSAs
            $gmsaIndex = New-Object System.Collections.Generic.List[psobject]
            try {
                $root = & $script:GetDe ("LDAP://${bindServer}/${domainDn}")
                $ds   = New-Object System.DirectoryServices.DirectorySearcher($root)
                $ds.PageSize = 1000
                $ds.Filter   = '(objectClass=msDS-GroupManagedServiceAccount)'
                $ds.PropertiesToLoad.AddRange(@('distinguishedName','sAMAccountName')) | Out-Null

                foreach ($r in $ds.FindAll()) {
                    $dn = $r.Properties['distinguishedname'][0]
                    $parent = if ($dn -and $dn.Contains(',')) { $dn.Substring($dn.IndexOf(',')+1) } else { $null }
                    $sam = if ($r.Properties['samaccountname']) { $r.Properties['samaccountname'][0] } else { $null }

                    $gmsaIndex.Add([pscustomobject]@{
                        DistinguishedName = $dn
                        ParentContainerDN = $parent
                        SamAccountName    = $sam
                    })
                }
            } catch {
                Write-IdentIRLog -Message "gMSA discovery failed in $domainDn via ${bindServer}: $($_.Exception.Message)" -TypeName 'Error' -ForegroundColor Red
            }

            Write-IdentIRLog -Message ("Found {0} gMSA object(s) in $domain" -f $gmsaIndex.Count) -TypeName 'Info' -ForegroundColor Green

            # Disable & tag -> clear SPNs/DNS -> delete -> confirm -> recreate
            $oldToNewMap = @{}
            $firstNewDn  = $null

            foreach ($g in $gmsaIndex) {
                $oldDn  = $g.DistinguishedName
                $parent = $g.ParentContainerDN
                $cn     = ($oldDn -split ',',2)[0] -replace '^CN='
                $sam    = $g.SamAccountName

                # backup attributes (best-effort)
                $exp = @{
                    DisplayName                         = $null
                    Description                         = $null
                    ServicePrincipalName                = @()
                    ManagedPasswordInterval             = 30
                    AllowedToDelegateTo                 = @()
                    UserAccountControl                  = $null
                    DnsHostName                         = $null
                    GroupMSAMembership                  = $null
                    AllowedToActOnBehalfOfOtherIdentity = $null
                    SupportedEncryptionTypes            = $null
                }

                try {
                    $xde = & $script:GetDe ("LDAP://${bindServer}/${oldDn}")

                    if ($xde.Properties['displayName'])                          { $exp.DisplayName     = $xde.Properties['displayName'][0] }
                    if ($xde.Properties['description'])                          { $exp.Description     = $xde.Properties['description'][0] }
                    if ($xde.Properties['servicePrincipalName'])                 { $exp.ServicePrincipalName = @($xde.Properties['servicePrincipalName']) }
                    if ($xde.Properties['msDS-ManagedPasswordInterval'])         { $exp.ManagedPasswordInterval = [int]$xde.Properties['msDS-ManagedPasswordInterval'][0] }
                    if ($xde.Properties['msDS-AllowedToDelegateTo'])             { $exp.AllowedToDelegateTo    = @($xde.Properties['msDS-AllowedToDelegateTo']) }
                    if ($xde.Properties['userAccountControl'])                   { $exp.UserAccountControl      = [int]$xde.Properties['userAccountControl'][0] }
                    if ($xde.Properties['dnsHostName'])                          { $exp.DnsHostName             = $xde.Properties['dnsHostName'][0] }
                    if ($xde.Properties['msDS-GroupMSAMembership'])              { $exp.GroupMSAMembership      = $xde.Properties['msDS-GroupMSAMembership'][0] }
                    if ($xde.Properties['msDS-AllowedToActOnBehalfOfOtherIdentity']) { $exp.AllowedToActOnBehalfOfOtherIdentity = $xde.Properties['msDS-AllowedToActOnBehalfOfOtherIdentity'][0] }
                    if ($xde.Properties['msDS-SupportedEncryptionTypes'])        { $exp.SupportedEncryptionTypes = [int]$xde.Properties['msDS-SupportedEncryptionTypes'][0] }
                } catch { }

                Write-IdentIRLog -Message "Backed up gMSA $oldDn (dnsHostName=$($exp.DnsHostName); SPNs=$($exp.ServicePrincipalName -join ', '))" -TypeName 'Info' -ForegroundColor Green

                # 1) Disable & tag OLD
                if ($whatIf) {
                    & $WI ("Disable + tag gMSA $oldDn")
                } else {
                    try {
                        $de  = & $script:GetDe ("LDAP://${bindServer}/${oldDn}")
                        $uac = [int]($de.Properties['userAccountControl'].Value)
                        $de.Properties['userAccountControl'].Value = ($uac -bor 0x2) # ACCOUNTDISABLE
                        $de.Properties['adminDescription'].Value   = $CleanupTag
                        $de.SetInfo()
                        Write-IdentIRLog -Message "Disabled and tagged gMSA $oldDn" -TypeName 'Info' -ForegroundColor Green
                    } catch {
                        Write-IdentIRLog -Message "Disable/tag failed for gMSA ${oldDn}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                    }
                }

                # 2) Clear SPNs & DNS on OLD
                if ($whatIf) {
                    & $WI ("Clear SPNs and dnsHostName on gMSA $oldDn")
                } else {
                    try {
                        $de = & $script:GetDe ("LDAP://${bindServer}/${oldDn}")
                        $de.Properties['servicePrincipalName'].Clear()
                        $de.Properties['dnsHostName'].Value = $null
                        $de.SetInfo()
                        Write-IdentIRLog -Message "Cleared SPNs and dnsHostName on gMSA $oldDn" -TypeName 'Info' -ForegroundColor Green
                    } catch {
                        Write-IdentIRLog -Message "Clearing SPNs/dnsHostName failed for gMSA ${oldDn}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                    }
                }

                if (-not $whatIf) { Start-Sleep -Seconds 2 }

                # 3) Delete OLD
                if ($whatIf) {
                    & $WI ("Delete gMSA $oldDn")
                } else {
                    try {
                        $parentDn = $oldDn.Substring($oldDn.IndexOf(',')+1)
                        $pde      = & $script:GetDe ("LDAP://${bindServer}/${parentDn}")
                        $pde.Delete("msDS-GroupManagedServiceAccount", "CN=$cn")
                        Write-IdentIRLog -Message "Deleted old gMSA $oldDn" -TypeName 'Info' -ForegroundColor Green
                    } catch {
                        Write-IdentIRLog -Message "Delete failed for gMSA ${oldDn}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                        continue
                    }
                    Start-Sleep -Seconds 2
                }

                # 4) Confirm CN gone
                $ou     = & $script:GetDe ("LDAP://${bindServer}/${parent}")
                $exists = $false

                if (-not $whatIf) {
                    $exists     = $true
                    $retryCount = 0
                    $maxRetries = 5

                    while ($exists -and $retryCount -lt $maxRetries) {
                        $exists = $false
                        try {
                            $dsCheck = New-Object System.DirectoryServices.DirectorySearcher($ou)
                            $dsCheck.Filter      = "(cn=$cn)"
                            $dsCheck.SearchScope = 'OneLevel'
                            if ($dsCheck.FindOne()) { $exists = $true }
                        } catch {
                            Write-IdentIRLog -Message "CN existence check failed for $cn in ${parent}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                        }

                        if ($exists) { Start-Sleep -Seconds 2 }
                        $retryCount++
                    }
                }

                if ($exists) {
                    Write-IdentIRLog -Message "CN $cn still present after retries; skipping recreate." -TypeName 'Warning' -ForegroundColor Yellow
                    continue
                }

                # Normalize sAM (end with $; <=15 chars)
                if ($sam -and -not $sam.EndsWith('$')) { $sam = "${sam}$" }
                if ($sam -and $sam.Length -gt 15) {
                    $oldSam = $sam
                    $sam    = $sam.Substring(0,15)
                    Write-IdentIRLog -Message "sAMAccountName '$oldSam' truncated to '$sam' to meet 15-character limit." -TypeName 'Warning' -ForegroundColor Yellow
                }

                # Generate dnsHostName if missing
                if (-not $exp.DnsHostName) {
                    $exp.DnsHostName = "$cn.$domainFqdn"
                    Write-IdentIRLog -Message "Generated dnsHostName for CN=$cn,$parent -> $($exp.DnsHostName)" -TypeName 'Info' -ForegroundColor Cyan
                }

                # 5) Recreate NEW gMSA
                $newDn = $null
                if ($whatIf) {
                    & $WI ("Create new gMSA CN=$cn,$parent (dnsHostName=$($exp.DnsHostName))")
                } else {
                    try {
                        $new = $ou.Create("msDS-GroupManagedServiceAccount", "CN=$cn")

                        if ($sam)                 { $new.Put("sAMAccountName", $sam) }
                        if ($exp.DisplayName)     { $new.Put("displayName", $exp.DisplayName) }
                        if ($exp.Description)     { $new.Put("description", $exp.Description) }
                        $new.Put("msDS-ManagedPasswordInterval", $exp.ManagedPasswordInterval)

                        $uac = if ($exp.UserAccountControl) { [int]$exp.UserAccountControl } else { 0x1000 } # WORKSTATION_TRUST_ACCOUNT
                        $uac = ($uac -band (-bnot 0x2)) # ensure enabled
                        $new.Put("userAccountControl", $uac)

                        $new.Put("dnsHostName", $exp.DnsHostName)
                        if ($exp.GroupMSAMembership)                  { $new.Put("msDS-GroupMSAMembership", $exp.GroupMSAMembership) }
                        if ($exp.AllowedToActOnBehalfOfOtherIdentity) { $new.Put("msDS-AllowedToActOnBehalfOfOtherIdentity", $exp.AllowedToActOnBehalfOfOtherIdentity) }
                        if ($null -ne $exp.SupportedEncryptionTypes) { $new.Put("msDS-SupportedEncryptionTypes", $exp.SupportedEncryptionTypes) }

                        $new.Properties['adminDescription'].Value = 'Restored'

                        # First commit core attributes
                        $new.SetInfo()

                        # Add SPNs / delegation
                        try {
                            foreach ($spn in @($exp.ServicePrincipalName)) {
                                [void]$new.Properties["servicePrincipalName"].Add($spn)
                            }
                        } catch {
                            Write-IdentIRLog -Message "Adding SPNs failed on CN=$cn,${parent}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                        }

                        try {
                            foreach ($svc in @($exp.AllowedToDelegateTo)) {
                                [void]$new.Properties["msDS-AllowedToDelegateTo"].Add($svc)
                            }
                        } catch {
                            Write-IdentIRLog -Message "Adding msDS-AllowedToDelegateTo failed on CN=$cn,${parent}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                        }

                        if ($exp.ServicePrincipalName.Count -gt 0 -or $exp.AllowedToDelegateTo.Count -gt 0) {
                            try { $new.SetInfo() } catch { }
                        }

                        $newDn = "CN=$cn,$parent"
                        Write-IdentIRLog -Message "Created new gMSA $newDn (Restored)" -TypeName 'Info' -ForegroundColor Green
                    } catch {
                        Write-IdentIRLog -Message "Create gMSA failed (CN=$cn,$parent): $($_.Exception.Message)" -TypeName 'Error' -ForegroundColor Red
                    }
                }

                if ($newDn) {
                    $oldToNewMap[$oldDn] = $newDn
                    if (-not $firstNewDn) { $firstNewDn = $newDn }
                }
            }

            # Optional host rebind
            if ($RebindHosts -and $oldToNewMap.Count -gt 0) {
                if ($whatIf) {
                    & $WI ("Rebind hosts in $domain using map (count=$($oldToNewMap.Count))")
                } else {
                    try {
                        $root = & $script:GetDe ("LDAP://${bindServer}/${domainDn}")
                        $ds   = New-Object System.DirectoryServices.DirectorySearcher($root)
                        $ds.PageSize = 1000
                        $ds.Filter   = '(&(objectCategory=computer)(msDS-HostServiceAccount=*))'
                        $ds.PropertiesToLoad.AddRange(@('distinguishedName','msDS-HostServiceAccount')) | Out-Null

                        $reboundCount = 0

                        foreach ($r in $ds.FindAll()) {
                            $compDn = $r.Properties['distinguishedname'][0]
                            $currentAccounts = @($r.Properties['msds-hostserviceaccount'])
                            $updated = $false

                            for ($i = 0; $i -lt $currentAccounts.Count; $i++) {
                                if ($oldToNewMap.ContainsKey($currentAccounts[$i])) {
                                    $currentAccounts[$i] = $oldToNewMap[$currentAccounts[$i]]
                                    $updated = $true
                                }
                            }

                            if ($updated) {
                                try {
                                    $cde = & $script:GetDe ("LDAP://${bindServer}/${compDn}")
                                    $cde.Properties['msDS-HostServiceAccount'].Clear()
                                    foreach ($acc in $currentAccounts) {
                                        [void]$cde.Properties['msDS-HostServiceAccount'].Add($acc)
                                    }
                                    $cde.SetInfo()
                                    Write-IdentIRLog -Message "Rebound host $compDn" -TypeName 'Info' -ForegroundColor White
                                    $reboundCount++
                                } catch {
                                    Write-IdentIRLog -Message "Rebind failed for host ${compDn}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                                }
                            }
                        }

                        Write-IdentIRLog -Message "Rebound $reboundCount host(s) in $domain" -TypeName 'Info' -ForegroundColor Green
                    } catch {
                        Write-IdentIRLog -Message "Host rebind query failed in ${domainDn}: $($_.Exception.Message)" -TypeName 'Error' -ForegroundColor Red
                    }
                }
            }

            # Verify new KDS usage (execution only). GUID starts at offset 24.
            if (-not $whatIf -and $gmsaIndex.Count -gt 0 -and $firstNewDn -and $newKdsCn) {
                try {
                    Start-Sleep -Seconds 2
                    $nde = & $script:GetDe ("LDAP://${bindServer}/${firstNewDn}")
                    $bytes = $nde.Properties['msDS-ManagedPasswordId'].Value
                    if ($bytes -and $bytes.Length -ge 40) {
                        [byte[]]$guidBytes = $bytes[24..39]
                        $extractedGuid = New-Object Guid -ArgumentList (,$guidBytes)
                        $extractedStr  = $extractedGuid.ToString()

                        if ($extractedStr -eq $newKdsCn) {
                            Write-IdentIRLog -Message "Verified gMSA $firstNewDn uses new KDS key $newKdsCn." -TypeName 'Info' -ForegroundColor Green
                        } else {
                            Write-IdentIRLog -Message "KDS verification mismatch for $firstNewDn (GUID $extractedStr vs new key $newKdsCn)." -TypeName 'Error' -ForegroundColor Red
                        }
                    } else {
                        Write-IdentIRLog -Message "msDS-ManagedPasswordId missing or too short for verification on $firstNewDn." -TypeName 'Warning' -ForegroundColor Yellow
                    }
                } catch {
                    Write-IdentIRLog -Message "KDS verification failed in ${domain}: $($_.Exception.Message)" -TypeName 'Warning' -ForegroundColor Yellow
                }
            }

            Write-IdentIRLog -Message "Completed gMSA Rotation Domain $domain" -TypeName 'Info' -ForegroundColor White
        }

        if ($whatIf) {
            Write-IdentIRLog -Message "gMSA operation simulation complete (WhatIf=True)." -TypeName 'Info' -ForegroundColor White
            return
        }

        # Old KDS key cleanup on forest-root PDC (only if we saw a new key)
        if ($script:existingKeyCount -gt 0 -and $script:newKdsCn) {
            try {
                $deleted = Remove-KdsRootKeys -BindServer $script:kdsBindServer -GetDe $script:GetDe -OldKeys $script:oldKeys
                if ($deleted -gt 0) {
                    Write-IdentIRLog -Message "Deleted $deleted old KDS root key(s) on forest-root PDC." -TypeName 'Info' -ForegroundColor Yellow
                } else {
                    Write-IdentIRLog -Message "No old KDS keys deleted on forest-root PDC (none matched or delete failed)." -TypeName 'Warning' -ForegroundColor Yellow
                }
                Force-ConfigReplication -SourceDC $script:kdsBindServer -CfgNC $script:cfgNC
            } catch {
                Write-IdentIRLog -Message "Old KDS key cleanup failed on forest-root PDC: $($_.Exception.Message)" -TypeName 'Error' -ForegroundColor Red
            }
        }

        # Final kdsSvc restart across all online DCs
        $allDcs = $script:validated |
            Where-Object { $_.Online } |
            ForEach-Object { $_.FQDN } |
            Sort-Object -Unique

        if ($script:whatIf) {
            foreach ($c in $allDcs) {
                & $WI ("Restart kdsSvc on $c (final pass)")
            }
        } else {
            $issF  = [System.Management.Automation.Runspaces.InitialSessionState]::CreateDefault()
            $poolF = [RunspaceFactory]::CreateRunspacePool(1, 16, $issF, $Host)
            $poolF.Open()
            $jobsF = @()

            foreach ($c in $allDcs) {
                $ps = [PowerShell]::Create()
                $ps.RunspacePool = $poolF
                $null = $ps.AddScript({
                    param($ComputerName)
                    try {
                        $c = @{
                            ClassName    = 'Win32_Service'
                            Filter       = "Name='kdsSvc'"
                            ComputerName = $ComputerName
                        }
                        $svc = Get-CimInstance @c
                        if (-not $svc) { return @{Computer=$ComputerName; Success=$false; Error='kdsSvc not found'} }

                        $null = $svc | Invoke-CimMethod -MethodName StopService
                        $deadline = (Get-Date).AddSeconds(60)
                        while ($svc.State -ne 'Stopped' -and (Get-Date) -lt $deadline) {
                            $svc = Get-CimInstance @c
                            Start-Sleep -Milliseconds 200
                        }
                        if ($svc.State -ne 'Stopped') { return @{Computer=$ComputerName; Success=$false; Error='Stop timed out'} }

                        $null = $svc | Invoke-CimMethod -MethodName StartService
                        $deadline = (Get-Date).AddSeconds(60)
                        while ($svc.State -ne 'Running' -and (Get-Date) -lt $deadline) {
                            $svc = Get-CimInstance @c
                            Start-Sleep -Milliseconds 200
                        }
                        if ($svc.State -ne 'Running') { return @{Computer=$ComputerName; Success=$false; Error='Start timed out'} }

                        return @{Computer=$ComputerName; Success=$true}
                    } catch {
                        return @{Computer=$ComputerName; Success=$false; Error=$_.Exception.Message}
                    }
                }).AddArgument($c)

                $jobsF += [pscustomobject]@{ PS = $ps; Handle = $ps.BeginInvoke() }
            }

            foreach ($j in $jobsF) {
                try {
                    $r = $j.PS.EndInvoke($j.Handle)
                } finally {
                    $j.PS.Dispose()
                }
                foreach ($x in $r) {
                    if ($x.Success) {
                        Write-IdentIRLog -Message "kdsSvc restarted on $($x.Computer) (final pass)" -TypeName 'Info' -ForegroundColor Green
                    } else {
                        Write-IdentIRLog -Message "kdsSvc restart failed on $($x.Computer) (final pass): $($x.Error)" -TypeName 'Warning' -ForegroundColor Yellow
                    }
                }
            }

            $poolF.Close()
            $poolF.Dispose()
        }

        Write-IdentIRLog -Message "gMSA rotation complete." -TypeName 'Info' -ForegroundColor White
    }
}
